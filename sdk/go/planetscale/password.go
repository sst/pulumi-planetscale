// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package planetscale

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sst/pulumi-planetscale/sdk/go/planetscale/internal"
)

// A PlanetScale database password.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/sst/pulumi-planetscale/sdk/go/planetscale"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := planetscale.NewPassword(ctx, "example", &planetscale.PasswordArgs{
//				Organization: pulumi.String("example"),
//				Database:     pulumi.String("example_db"),
//				Branch:       pulumi.String("main"),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("password", example)
//			return nil
//		})
//	}
//
// ```
type Password struct {
	pulumi.CustomResourceState

	// The host URL for the password.
	AccessHostUrl pulumi.StringOutput `pulumi:"accessHostUrl"`
	// The actor that created this branch.
	Actor PasswordActorOutput `pulumi:"actor"`
	// The branch this password belongs to.
	Branch pulumi.StringOutput `pulumi:"branch"`
	// When the password was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// The datanase this branch password belongs to.
	Database pulumi.StringOutput `pulumi:"database"`
	// The branch this password is allowed to access.
	DatabaseBranch PasswordDatabaseBranchOutput `pulumi:"databaseBranch"`
	// When the password was deleted.
	DeletedAt pulumi.StringOutput `pulumi:"deletedAt"`
	// When the password will expire.
	ExpiresAt pulumi.StringOutput `pulumi:"expiresAt"`
	// The display name for the password.
	Name pulumi.StringOutput `pulumi:"name"`
	// The organization this database branch password belongs to.
	Organization pulumi.StringOutput `pulumi:"organization"`
	// The plaintext password, only available if the password was created by this provider.
	Plaintext pulumi.StringOutput `pulumi:"plaintext"`
	// The region in which this password can be used.
	Region PasswordRegionOutput `pulumi:"region"`
	// Whether or not the password can be renewed.
	Renewable pulumi.BoolOutput `pulumi:"renewable"`
	// The role for the password.
	Role pulumi.StringOutput `pulumi:"role"`
	// Time to live (in seconds) for the password. The password will be invalid and unrenewable when TTL has passed.
	TtlSeconds pulumi.Float64Output `pulumi:"ttlSeconds"`
	// The username for the password.
	Username pulumi.StringOutput `pulumi:"username"`
}

// NewPassword registers a new resource with the given unique name, arguments, and options.
func NewPassword(ctx *pulumi.Context,
	name string, args *PasswordArgs, opts ...pulumi.ResourceOption) (*Password, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Branch == nil {
		return nil, errors.New("invalid value for required argument 'Branch'")
	}
	if args.Database == nil {
		return nil, errors.New("invalid value for required argument 'Database'")
	}
	if args.Organization == nil {
		return nil, errors.New("invalid value for required argument 'Organization'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"plaintext",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Password
	err := ctx.RegisterResource("planetscale:index/password:Password", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPassword gets an existing Password resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPassword(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PasswordState, opts ...pulumi.ResourceOption) (*Password, error) {
	var resource Password
	err := ctx.ReadResource("planetscale:index/password:Password", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Password resources.
type passwordState struct {
	// The host URL for the password.
	AccessHostUrl *string `pulumi:"accessHostUrl"`
	// The actor that created this branch.
	Actor *PasswordActor `pulumi:"actor"`
	// The branch this password belongs to.
	Branch *string `pulumi:"branch"`
	// When the password was created.
	CreatedAt *string `pulumi:"createdAt"`
	// The datanase this branch password belongs to.
	Database *string `pulumi:"database"`
	// The branch this password is allowed to access.
	DatabaseBranch *PasswordDatabaseBranch `pulumi:"databaseBranch"`
	// When the password was deleted.
	DeletedAt *string `pulumi:"deletedAt"`
	// When the password will expire.
	ExpiresAt *string `pulumi:"expiresAt"`
	// The display name for the password.
	Name *string `pulumi:"name"`
	// The organization this database branch password belongs to.
	Organization *string `pulumi:"organization"`
	// The plaintext password, only available if the password was created by this provider.
	Plaintext *string `pulumi:"plaintext"`
	// The region in which this password can be used.
	Region *PasswordRegion `pulumi:"region"`
	// Whether or not the password can be renewed.
	Renewable *bool `pulumi:"renewable"`
	// The role for the password.
	Role *string `pulumi:"role"`
	// Time to live (in seconds) for the password. The password will be invalid and unrenewable when TTL has passed.
	TtlSeconds *float64 `pulumi:"ttlSeconds"`
	// The username for the password.
	Username *string `pulumi:"username"`
}

type PasswordState struct {
	// The host URL for the password.
	AccessHostUrl pulumi.StringPtrInput
	// The actor that created this branch.
	Actor PasswordActorPtrInput
	// The branch this password belongs to.
	Branch pulumi.StringPtrInput
	// When the password was created.
	CreatedAt pulumi.StringPtrInput
	// The datanase this branch password belongs to.
	Database pulumi.StringPtrInput
	// The branch this password is allowed to access.
	DatabaseBranch PasswordDatabaseBranchPtrInput
	// When the password was deleted.
	DeletedAt pulumi.StringPtrInput
	// When the password will expire.
	ExpiresAt pulumi.StringPtrInput
	// The display name for the password.
	Name pulumi.StringPtrInput
	// The organization this database branch password belongs to.
	Organization pulumi.StringPtrInput
	// The plaintext password, only available if the password was created by this provider.
	Plaintext pulumi.StringPtrInput
	// The region in which this password can be used.
	Region PasswordRegionPtrInput
	// Whether or not the password can be renewed.
	Renewable pulumi.BoolPtrInput
	// The role for the password.
	Role pulumi.StringPtrInput
	// Time to live (in seconds) for the password. The password will be invalid and unrenewable when TTL has passed.
	TtlSeconds pulumi.Float64PtrInput
	// The username for the password.
	Username pulumi.StringPtrInput
}

func (PasswordState) ElementType() reflect.Type {
	return reflect.TypeOf((*passwordState)(nil)).Elem()
}

type passwordArgs struct {
	// The branch this password belongs to.
	Branch string `pulumi:"branch"`
	// The datanase this branch password belongs to.
	Database string `pulumi:"database"`
	// The display name for the password.
	Name *string `pulumi:"name"`
	// The organization this database branch password belongs to.
	Organization string `pulumi:"organization"`
	// The role for the password.
	Role *string `pulumi:"role"`
	// Time to live (in seconds) for the password. The password will be invalid and unrenewable when TTL has passed.
	TtlSeconds *float64 `pulumi:"ttlSeconds"`
}

// The set of arguments for constructing a Password resource.
type PasswordArgs struct {
	// The branch this password belongs to.
	Branch pulumi.StringInput
	// The datanase this branch password belongs to.
	Database pulumi.StringInput
	// The display name for the password.
	Name pulumi.StringPtrInput
	// The organization this database branch password belongs to.
	Organization pulumi.StringInput
	// The role for the password.
	Role pulumi.StringPtrInput
	// Time to live (in seconds) for the password. The password will be invalid and unrenewable when TTL has passed.
	TtlSeconds pulumi.Float64PtrInput
}

func (PasswordArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*passwordArgs)(nil)).Elem()
}

type PasswordInput interface {
	pulumi.Input

	ToPasswordOutput() PasswordOutput
	ToPasswordOutputWithContext(ctx context.Context) PasswordOutput
}

func (*Password) ElementType() reflect.Type {
	return reflect.TypeOf((**Password)(nil)).Elem()
}

func (i *Password) ToPasswordOutput() PasswordOutput {
	return i.ToPasswordOutputWithContext(context.Background())
}

func (i *Password) ToPasswordOutputWithContext(ctx context.Context) PasswordOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PasswordOutput)
}

// PasswordArrayInput is an input type that accepts PasswordArray and PasswordArrayOutput values.
// You can construct a concrete instance of `PasswordArrayInput` via:
//
//	PasswordArray{ PasswordArgs{...} }
type PasswordArrayInput interface {
	pulumi.Input

	ToPasswordArrayOutput() PasswordArrayOutput
	ToPasswordArrayOutputWithContext(context.Context) PasswordArrayOutput
}

type PasswordArray []PasswordInput

func (PasswordArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Password)(nil)).Elem()
}

func (i PasswordArray) ToPasswordArrayOutput() PasswordArrayOutput {
	return i.ToPasswordArrayOutputWithContext(context.Background())
}

func (i PasswordArray) ToPasswordArrayOutputWithContext(ctx context.Context) PasswordArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PasswordArrayOutput)
}

// PasswordMapInput is an input type that accepts PasswordMap and PasswordMapOutput values.
// You can construct a concrete instance of `PasswordMapInput` via:
//
//	PasswordMap{ "key": PasswordArgs{...} }
type PasswordMapInput interface {
	pulumi.Input

	ToPasswordMapOutput() PasswordMapOutput
	ToPasswordMapOutputWithContext(context.Context) PasswordMapOutput
}

type PasswordMap map[string]PasswordInput

func (PasswordMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Password)(nil)).Elem()
}

func (i PasswordMap) ToPasswordMapOutput() PasswordMapOutput {
	return i.ToPasswordMapOutputWithContext(context.Background())
}

func (i PasswordMap) ToPasswordMapOutputWithContext(ctx context.Context) PasswordMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PasswordMapOutput)
}

type PasswordOutput struct{ *pulumi.OutputState }

func (PasswordOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Password)(nil)).Elem()
}

func (o PasswordOutput) ToPasswordOutput() PasswordOutput {
	return o
}

func (o PasswordOutput) ToPasswordOutputWithContext(ctx context.Context) PasswordOutput {
	return o
}

// The host URL for the password.
func (o PasswordOutput) AccessHostUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.AccessHostUrl }).(pulumi.StringOutput)
}

// The actor that created this branch.
func (o PasswordOutput) Actor() PasswordActorOutput {
	return o.ApplyT(func(v *Password) PasswordActorOutput { return v.Actor }).(PasswordActorOutput)
}

// The branch this password belongs to.
func (o PasswordOutput) Branch() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.Branch }).(pulumi.StringOutput)
}

// When the password was created.
func (o PasswordOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// The datanase this branch password belongs to.
func (o PasswordOutput) Database() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.Database }).(pulumi.StringOutput)
}

// The branch this password is allowed to access.
func (o PasswordOutput) DatabaseBranch() PasswordDatabaseBranchOutput {
	return o.ApplyT(func(v *Password) PasswordDatabaseBranchOutput { return v.DatabaseBranch }).(PasswordDatabaseBranchOutput)
}

// When the password was deleted.
func (o PasswordOutput) DeletedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.DeletedAt }).(pulumi.StringOutput)
}

// When the password will expire.
func (o PasswordOutput) ExpiresAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.ExpiresAt }).(pulumi.StringOutput)
}

// The display name for the password.
func (o PasswordOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The organization this database branch password belongs to.
func (o PasswordOutput) Organization() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.Organization }).(pulumi.StringOutput)
}

// The plaintext password, only available if the password was created by this provider.
func (o PasswordOutput) Plaintext() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.Plaintext }).(pulumi.StringOutput)
}

// The region in which this password can be used.
func (o PasswordOutput) Region() PasswordRegionOutput {
	return o.ApplyT(func(v *Password) PasswordRegionOutput { return v.Region }).(PasswordRegionOutput)
}

// Whether or not the password can be renewed.
func (o PasswordOutput) Renewable() pulumi.BoolOutput {
	return o.ApplyT(func(v *Password) pulumi.BoolOutput { return v.Renewable }).(pulumi.BoolOutput)
}

// The role for the password.
func (o PasswordOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.Role }).(pulumi.StringOutput)
}

// Time to live (in seconds) for the password. The password will be invalid and unrenewable when TTL has passed.
func (o PasswordOutput) TtlSeconds() pulumi.Float64Output {
	return o.ApplyT(func(v *Password) pulumi.Float64Output { return v.TtlSeconds }).(pulumi.Float64Output)
}

// The username for the password.
func (o PasswordOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v *Password) pulumi.StringOutput { return v.Username }).(pulumi.StringOutput)
}

type PasswordArrayOutput struct{ *pulumi.OutputState }

func (PasswordArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Password)(nil)).Elem()
}

func (o PasswordArrayOutput) ToPasswordArrayOutput() PasswordArrayOutput {
	return o
}

func (o PasswordArrayOutput) ToPasswordArrayOutputWithContext(ctx context.Context) PasswordArrayOutput {
	return o
}

func (o PasswordArrayOutput) Index(i pulumi.IntInput) PasswordOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Password {
		return vs[0].([]*Password)[vs[1].(int)]
	}).(PasswordOutput)
}

type PasswordMapOutput struct{ *pulumi.OutputState }

func (PasswordMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Password)(nil)).Elem()
}

func (o PasswordMapOutput) ToPasswordMapOutput() PasswordMapOutput {
	return o
}

func (o PasswordMapOutput) ToPasswordMapOutputWithContext(ctx context.Context) PasswordMapOutput {
	return o
}

func (o PasswordMapOutput) MapIndex(k pulumi.StringInput) PasswordOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Password {
		return vs[0].(map[string]*Password)[vs[1].(string)]
	}).(PasswordOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PasswordInput)(nil)).Elem(), &Password{})
	pulumi.RegisterInputType(reflect.TypeOf((*PasswordArrayInput)(nil)).Elem(), PasswordArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PasswordMapInput)(nil)).Elem(), PasswordMap{})
	pulumi.RegisterOutputType(PasswordOutput{})
	pulumi.RegisterOutputType(PasswordArrayOutput{})
	pulumi.RegisterOutputType(PasswordMapOutput{})
}
